{
  "file": "calculator/ui/cli.py",
  "analysis": {
    "issues": [
      {
        "description": "The newly-exposed \u201crandom\u201d operation is treated as if it required two operands.",
        "reason": "random_operation is listed in `self.operations` but it is NOT included in `SINGLE_ARG_OPERATIONS`. Consequently `parse_input()` and `_validate_operands()` will insist on at least one (actually two) numeric operands, so a perfectly valid command such as `random` will fail with *Missing first operand* or *Operation \u2026 requires two operands*.",
        "fix": "Introduce a dedicated `ZERO_ARG_OPERATIONS` constant that currently contains {\"random\"}.  Update `parse_input()`, `_validate_operands()` and `display_menu()` so that they recognise zero-argument operations."
      },
      {
        "description": "Division by zero is explicitly prevented, but modulus by zero is silently allowed.",
        "reason": "Passing 0 as the second operand of a modulus operation (`x % 0`) raises a `ZeroDivisionError` inside `basic_operations.modulus`, which is then caught in `calculate()` and converted into a generic *Error: division by zero* string.  We should detect it ourselves and raise a clearer, uniform `ValueError`, just like we do for division.",
        "fix": "Extend the special-case check in `_validate_operands()` so that `op_name == 'modulus' and b == 0` is handled in exactly the same way as division."
      },
      {
        "description": "`calculate()` cannot record history for zero-argument operations.",
        "reason": "The current implementation only distinguishes between one- and two-operand invocations.  When the length of the operand tuple is 0 (e.g. the new \"random\" case) `self.history.add_calculation()` is never called, so the result is lost from history.",
        "fix": "Add an explicit branch for the zero-operand variant so that every calculation is recorded uniformly."
      },
      {
        "description": "User input for zero-argument operations is over-validated in `parse_input()`.",
        "reason": "`parse_input()` always tries to coerce at least one operand into a float unless the operation is in `SINGLE_ARG_OPERATIONS`.  For zero-argument commands this will throw *Missing first operand.*",
        "fix": "Skip operand parsing altogether when the operation belongs to `ZERO_ARG_OPERATIONS`."
      }
    ],
    "fixed_code": "from calculator.operations import basic_operations, advanced_operations\nfrom calculator.utils import validation, memory\n\n\nclass CalculatorCLI:\n    \"\"\"Command-line interface for the calculator.\"\"\"\n\n    # Argument arity definitions ------------------------------------------------\n    ZERO_ARG_OPERATIONS = {\"random\"}\n    SINGLE_ARG_OPERATIONS = {\"sqrt\", \"factorial\", \"sin\"}\n\n    def __init__(self):\n        \"\"\"Initialise a new calculator CLI instance with its own history.\"\"\"\n        self.history = memory.CalculationHistory()\n        self.operations = {\n            \"add\": basic_operations.add,\n            \"subtract\": basic_operations.subtract,\n            \"multiply\": basic_operations.multiply,\n            \"divide\": basic_operations.divide,\n            \"power\": basic_operations.power,\n            \"modulus\": basic_operations.modulus,\n            \"sqrt\": advanced_operations.square_root,\n            \"factorial\": advanced_operations.factorial,\n            \"log\": advanced_operations.logarithm,\n            \"sin\": advanced_operations.sine,\n            \"random\": advanced_operations.random_operation,  # newly exposed\n        }\n\n    # ------------------------------------------------------------------\n    # Internal helpers\n    # ------------------------------------------------------------------\n    def get_operation(self, operation_name):\n        \"\"\"Return the function associated with *operation_name*.\"\"\"\n        try:\n            return self.operations[operation_name]\n        except KeyError as exc:\n            raise ValueError(f\"Unsupported operation '{operation_name}'.\") from exc\n\n    def _validate_operands(self, op_name, a, b):\n        \"\"\"Validate and return a tuple of operands suitable for *op_name*.\"\"\"\n\n        # Zero-argument operations -------------------------------------\n        if op_name in self.ZERO_ARG_OPERATIONS:\n            if a is not None or b is not None:\n                raise ValueError(f\"Operation '{op_name}' does not take any operands.\")\n            return tuple()\n\n        # Single-argument operations -----------------------------------\n        if op_name in self.SINGLE_ARG_OPERATIONS:\n            if not validation.is_number(a):\n                raise ValueError(\"Operand must be a valid number\")\n            return (a,)\n\n        # Two-argument operations --------------------------------------\n        if b is None:\n            raise ValueError(f\"Operation '{op_name}' requires two operands.\")\n\n        if not validation.is_number(a):\n            raise ValueError(\"First operand must be a valid number\")\n        if not validation.is_number(b):\n            raise ValueError(\"Second operand must be a valid number\")\n\n        # Special cases ------------------------------------------------\n        if op_name == \"divide\" and b == 0:\n            raise ValueError(\"Cannot divide by zero\")\n        if op_name == \"modulus\" and b == 0:\n            raise ValueError(\"Cannot perform modulus by zero\")\n\n        return (a, b)\n\n    # ------------------------------------------------------------------\n    # Public API\n    # ------------------------------------------------------------------\n    def calculate(self, operation_name, a=None, b=None):\n        \"\"\"Perform *operation_name* on the supplied operands and store the result.\"\"\"\n        try:\n            operation = self.get_operation(operation_name)\n            operands = self._validate_operands(operation_name, a, b)\n\n            # Execute ---------------------------------------------------\n            result = operation(*operands)\n\n            # Uniform history recording --------------------------------\n            if len(operands) == 0:\n                self.history.add_calculation(operation_name, None, None, result)\n            elif len(operands) == 1:\n                self.history.add_calculation(operation_name, operands[0], None, result)\n            else:\n                self.history.add_calculation(operation_name, operands[0], operands[1], result)\n\n            return result\n        except Exception as e:\n            return f\"Error: {str(e)}\"\n\n    # ------------------------------------------------------------------\n    # User-facing helpers\n    # ------------------------------------------------------------------\n    def display_menu(self):\n        \"\"\"Print a friendly help/usage screen to the console.\"\"\"\n        print(\"=== Calculator Menu ===\")\n        print(\"Enter commands in the following format:\\n\")\n        print(\"    <operation> <number1> [<number2>]\\n\")\n        print(\"Examples:\")\n        print(\"    add 5 10        \u2192 15\")\n        print(\"    sqrt 9          \u2192 3\\n\")\n        print(\"Available operations:\")\n        for op in sorted(self.operations):\n            if op in self.ZERO_ARG_OPERATIONS:\n                req = \"0 args\"\n            elif op in self.SINGLE_ARG_OPERATIONS:\n                req = \"1 arg\"\n            else:\n                req = \"2 args\"\n            print(f\" - {op:<10} ({req})\")\n\n    def parse_input(self, user_input):\n        \"\"\"Parse *user_input* and return *(operation, a, b)*.\"\"\"\n        parts = user_input.strip().split()\n        if not parts:\n            raise ValueError(\"Empty input.\")\n\n        operation = parts[0].lower()\n        if operation not in self.operations:\n            raise ValueError(f\"Unsupported operation '{operation}'.\")\n\n        # Zero-argument handling --------------------------------------\n        if operation in self.ZERO_ARG_OPERATIONS:\n            if len(parts) > 1:\n                raise ValueError(f\"Operation '{operation}' does not accept operands.\")\n            return operation, None, None\n\n        # First operand ------------------------------------------------\n        try:\n            a = float(parts[1])\n        except IndexError:\n            raise ValueError(\"Missing first operand.\")\n        except ValueError as exc:\n            raise ValueError(\"First operand is not a valid number.\") from exc\n\n        # Second operand (if required) ---------------------------------\n        b = None\n        if operation not in self.SINGLE_ARG_OPERATIONS:\n            try:\n                b = float(parts[2])\n            except IndexError:\n                raise ValueError(f\"Operation '{operation}' requires two operands.\")\n            except ValueError as exc:\n                raise ValueError(\"Second operand is not a valid number.\") from exc\n\n        return operation, a, b\n"
  },
  "time_taken": 36.07308626174927
}
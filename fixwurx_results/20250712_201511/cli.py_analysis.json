{
  "file": "calculator/ui/cli.py",
  "analysis": {
    "issues": [
      {
        "description": "The newly\u2013exposed \"random\" operation cannot be used because the CLI assumes that every operation that is not included in SINGLE_ARG_OPERATIONS requires two numeric operands.",
        "reason": "parse_input() tries to read two numeric operands for every operation that is not listed in SINGLE_ARG_OPERATIONS. Since \"random\" is not in that set, the parser raises an error when the user types just \"random\". The subsequent _validate_operands() routine will also insist on two operands and fail.",
        "fix": "Introduce explicit arity support (ZERO_ARG_OPERATIONS, SINGLE_ARG_OPERATIONS, TWO_ARG by default). Update parse_input() and _validate_operands() to handle zero-argument operations correctly."
      },
      {
        "description": "Missing validation for modulus by zero.",
        "reason": "The code pre-emptively rejects division by zero, but the modulus operation (% in Python) also raises ZeroDivisionError when the right-hand side is 0.  Not checking leads to an unhandled run-time exception.",
        "fix": "Add an explicit 0-check for modulus in _validate_operands(), similar to the one already present for divide."
      },
      {
        "description": "Factorial operands are coerced to float even though factorial is mathematically defined only for non-negative integers.",
        "reason": "parse_input() always casts numeric tokens to float. Passing 5.0 to math.factorial (or a custom factorial implementation) generally raises a TypeError. Even if it doesn\u2019t, accepting non-integers for factorial is semantically wrong.",
        "fix": "After the generic numeric validation, add extra semantic validation for the factorial operation: the value must be an integer and >= 0. Convert the operand to int so downstream code receives the correct type."
      },
      {
        "description": "calculate() swallows every exception and returns a string prefixed with \"Error:\" while successful calls return a number.",
        "reason": "Mixing return types (number vs. string) complicates downstream handling and hides stack traces that might be useful for debugging.",
        "fix": "Let calculate() propagate exceptions to the caller (or catch only specific, well-known exceptions if the design really mandates it). Caller code (CLI REPL, tests, GUI, \u2026) can then decide how to present the error."
      },
      {
        "description": "Extraneous operands for single-argument operations are silently ignored when calculate() is called directly.",
        "reason": "_validate_operands() simply returns (a,) when op_name is in SINGLE_ARG_OPERATIONS, discarding b. This can hide API misuse and lead to inconsistent history entries.",
        "fix": "If b is supplied for a single-argument operation, raise a ValueError rather than ignoring it."
      },
      {
        "description": "The menu text and argument count information do not reflect zero-argument operations, making the help screen misleading.",
        "reason": "display_menu() always prints either \u201c1 arg\u201d or \u201c2 args\u201d.",
        "fix": "Teach display_menu() about zero-argument operations and show the correct arity in the usage examples."
      }
    ],
    "fixed_code": "from calculator.operations import basic_operations, advanced_operations\nfrom calculator.utils import validation, memory\n\n\nclass CalculatorCLI:\n    \"\"\"Command-line interface for the calculator.\"\"\"\n\n    # ------------------------------------------------------------------\n    # Operation arity definitions\n    # ------------------------------------------------------------------\n    ZERO_ARG_OPERATIONS = {\"random\"}\n    SINGLE_ARG_OPERATIONS = {\"sqrt\", \"factorial\", \"sin\", \"log\"}  # log returns log10(x), one operand\n    # Any operation not listed above is assumed to require two operands.\n\n    def __init__(self):\n        \"\"\"Initialise a new calculator CLI instance with its own history.\"\"\"\n        self.history = memory.CalculationHistory()\n        self.operations = {\n            \"add\": basic_operations.add,\n            \"subtract\": basic_operations.subtract,\n            \"multiply\": basic_operations.multiply,\n            \"divide\": basic_operations.divide,\n            \"power\": basic_operations.power,\n            \"modulus\": basic_operations.modulus,\n            \"sqrt\": advanced_operations.square_root,\n            \"factorial\": advanced_operations.factorial,\n            \"log\": advanced_operations.logarithm,\n            \"sin\": advanced_operations.sine,\n            \"random\": advanced_operations.random_operation,  # 0-argument operation\n        }\n\n    # ------------------------------------------------------------------\n    # Internal helpers\n    # ------------------------------------------------------------------\n    def get_operation(self, operation_name):\n        \"\"\"Return the function associated with *operation_name*.\n\n        Raises\n        ------\n        ValueError\n            If the operation name is not recognised.\n        \"\"\"\n        try:\n            return self.operations[operation_name]\n        except KeyError as exc:\n            raise ValueError(f\"Unsupported operation '{operation_name}'.\") from exc\n\n    def _validate_operands(self, op_name, a=None, b=None):\n        \"\"\"Validate operands and return a tuple suitable for *op_name*.\"\"\"\n\n        # 0-argument operations -----------------------------------------\n        if op_name in self.ZERO_ARG_OPERATIONS:\n            if a is not None or b is not None:\n                raise ValueError(f\"Operation '{op_name}' does not take operands.\")\n            return tuple()\n\n        # 1-argument operations -----------------------------------------\n        if op_name in self.SINGLE_ARG_OPERATIONS:\n            if a is None:\n                raise ValueError(f\"Operation '{op_name}' requires one operand.\")\n            if b is not None:\n                raise ValueError(f\"Operation '{op_name}' takes exactly one operand.\")\n            if not validation.is_number(a):\n                raise ValueError(\"Operand must be a valid number\")\n\n            # Extra semantic checks ------------------------------------\n            if op_name == \"factorial\":\n                if not float(a).is_integer() or a < 0:\n                    raise ValueError(\"Factorial operand must be a non-negative integer\")\n                a = int(a)\n            return (a,)\n\n        # 2-argument operations -----------------------------------------\n        if a is None or b is None:\n            raise ValueError(f\"Operation '{op_name}' requires two operands.\")\n        if not validation.is_number(a):\n            raise ValueError(\"First operand must be a valid number\")\n        if not validation.is_number(b):\n            raise ValueError(\"Second operand must be a valid number\")\n\n        # Special zero-division rules -----------------------------------\n        if op_name in {\"divide\", \"modulus\"} and b == 0:\n            raise ValueError(f\"Cannot {op_name} by zero\")\n\n        return (a, b)\n\n    # ------------------------------------------------------------------\n    # Public API\n    # ------------------------------------------------------------------\n    def calculate(self, operation_name, a=None, b=None):\n        \"\"\"Perform *operation_name* on the supplied operands and store the result.\n\n        The method now propagates exceptions so that calling code can handle\n        them uniformly.  It always returns the numeric result if successful.\n        \"\"\"\n        operation = self.get_operation(operation_name)\n        operands = self._validate_operands(operation_name, a, b)\n        result = operation(*operands)\n\n        # Store the calculation uniformly ------------------------------\n        if len(operands) == 0:\n            self.history.add_calculation(operation_name, None, None, result)\n        elif len(operands) == 1:\n            self.history.add_calculation(operation_name, operands[0], None, result)\n        else:\n            self.history.add_calculation(operation_name, operands[0], operands[1], result)\n\n        return result\n\n    # ------------------------------------------------------------------\n    # User-facing helpers\n    # ------------------------------------------------------------------\n    def display_menu(self):\n        \"\"\"Print a friendly help/usage screen to the console.\"\"\"\n        print(\"=== Calculator Menu ===\")\n        print(\"Enter commands in the following format:\\n\")\n        print(\"    <operation> [<number1>] [<number2>]\\n\")\n        print(\"Examples:\")\n        print(\"    add 5 10        \u2192 15\")\n        print(\"    sqrt 9          \u2192 3\")\n        print(\"    random          \u2192 0.83465\\n\")\n        print(\"Available operations:\")\n\n        for op in sorted(self.operations):\n            if op in self.ZERO_ARG_OPERATIONS:\n                req = \"0 args\"\n            elif op in self.SINGLE_ARG_OPERATIONS:\n                req = \"1 arg\"\n            else:\n                req = \"2 args\"\n            print(f\" - {op:<10} ({req})\")\n\n    def parse_input(self, user_input):\n        \"\"\"Parse *user_input* and return *(operation, a, b)*.\n\n        Raises\n        ------\n        ValueError\n            For any syntactic or semantic problem in the input string.\n        \"\"\"\n        parts = user_input.strip().split()\n        if not parts:\n            raise ValueError(\"Empty input.\")\n\n        operation = parts[0].lower()\n        if operation not in self.operations:\n            raise ValueError(f\"Unsupported operation '{operation}'.\")\n\n        # 0-argument operations ----------------------------------------\n        if operation in self.ZERO_ARG_OPERATIONS:\n            if len(parts) != 1:\n                raise ValueError(f\"Operation '{operation}' accepts no operands.\")\n            return operation, None, None\n\n        # 1-argument operations ----------------------------------------\n        if operation in self.SINGLE_ARG_OPERATIONS:\n            try:\n                a = float(parts[1])\n            except IndexError:\n                raise ValueError(\"Missing operand.\")\n            except ValueError as exc:\n                raise ValueError(\"Operand is not a valid number.\") from exc\n            return operation, a, None\n\n        # 2-argument operations ----------------------------------------\n        try:\n            a = float(parts[1])\n        except IndexError:\n            raise ValueError(\"Missing first operand.\")\n        except ValueError as exc:\n            raise ValueError(\"First operand is not a valid number.\") from exc\n\n        try:\n            b = float(parts[2])\n        except IndexError:\n            raise ValueError(f\"Operation '{operation}' requires two operands.\")\n        except ValueError as exc:\n            raise ValueError(\"Second operand is not a valid number.\") from exc\n\n        return operation, a, b\n"
  },
  "time_taken": 58.35762977600098
}
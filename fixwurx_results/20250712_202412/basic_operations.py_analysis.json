{
  "file": "calculator/operations/basic_operations.py",
  "analysis": {
    "issues": [
      {
        "description": "Boolean values (`True` / `False`) are accepted as valid operands.",
        "reason": "In Python, `bool` is a subclass of `int`, so `isinstance(True, int)` returns `True`.  As a consequence, `_validate_numbers` silently accepts boolean values even though they are almost never intended to be processed by a calculator\u2019s arithmetic functions (e.g. `add(True, 3)` returns `4`).  This can lead to surprising results and subtle bugs when the caller unknowingly passes booleans.",
        "fix": "Explicitly reject `bool` in `_validate_numbers` by checking for it before the `int`/`float` check (or by checking `numbers.Real` and then excluding `bool`)."
      },
      {
        "description": "The `ZeroDivisionError` / `Modulus by zero` guard uses `b == 0`, which does not catch `0.0`, `-0.0`, or values *numerically* very close to zero for floating-point numbers.",
        "reason": "While `0.0 == 0` is `True` (so it is caught), the current wording of the docstring (\u201c*If **b** is 0*\u201d) strongly suggests *exact* equality.  For floating-point work you often want to regard *very small* denominators as numerical zeros to avoid huge or undefined results (e.g. `divide(1.0, 1e-308)` will return `inf` without raising, which is usually undesirable in a calculator application).",
        "fix": "Use `math.isclose(b, 0.0, abs_tol=<tiny>)` so the caller can configure an appropriate tolerance (chosen here as `1e-12`).  Also explicitly mention the behaviour in the docstring."
      },
      {
        "description": "Type alias `Number = Union[int, float]` omits `decimal.Decimal` or `fractions.Fraction`, which are valid numeric types frequently used in precise calculations.",
        "reason": "Restricting to only `int` and `float` may unnecessarily limit the calculator\u2019s utility and can cause typing errors when users try to use higher-precision numeric types.  At runtime these types will be rejected by `_validate_numbers` even though they behave like numbers.",
        "fix": "Replace the alias with `numbers.Real` (from the standard `numbers` module) so any real number implementation that conforms to the abstract base class is accepted.  This is both more future-proof and aligned with PEP-3141\u2019s numeric tower."
      },
      {
        "description": "Duplicated zero-division checks in both `divide` and `modulus` functions.",
        "reason": "`float` and `int` division/modulus already raise `ZeroDivisionError` by themselves.  Keeping the manual check is fine for a better message, but it duplicates logic.  It is better to factor out the common logic into `_validate_non_zero_divisor` to keep code DRY and improve maintainability.",
        "fix": "Create `_validate_non_zero_divisor(b: Number)` and call it from `divide` and `modulus`."
      }
    ],
    "fixed_code": "from __future__ import annotations\n\"\"\"\nBasic arithmetic operations for the calculator application.\nNow contains stricter type validation, configurable near-zero handling,\nand reduced code duplication.\n\"\"\"\n\nimport math\nfrom numbers import Real\nfrom typing import Final\n\n# ---------------------------------------------------------------------------\n# Type alias\n# ---------------------------------------------------------------------------\nNumber = Real  # Accepts int, float, decimal.Decimal, fractions.Fraction, etc.\n\n# ---------------------------------------------------------------------------\n# Configuration constants\n# ---------------------------------------------------------------------------\n_NEAR_ZERO_TOLERANCE: Final[float] = 1e-12  # configurable absolute tolerance\n\n# ---------------------------------------------------------------------------\n# Validation helpers\n# ---------------------------------------------------------------------------\n\ndef _validate_numbers(*args: Number) -> None:\n    \"\"\"Ensure every argument is a real number (but *not* bool).\"\"\"\n    for arg in args:\n        # Reject bool first \u2013 bool is a subclass of int\n        if isinstance(arg, bool):\n            raise TypeError(\"Operands must be numeric (int/float/etc.), bool is not allowed.\")\n        if not isinstance(arg, Real):\n            raise TypeError(\n                f\"Operands must be real numbers (int, float, Decimal, Fraction, ...); got {type(arg).__name__}.\"\n            )\n\n\ndef _validate_non_zero_divisor(b: Number) -> None:\n    \"\"\"Ensure *b* is not numerically zero (within tolerance).\"\"\"\n    if math.isclose(b, 0.0, abs_tol=_NEAR_ZERO_TOLERANCE):\n        raise ZeroDivisionError(\"Division or modulus by (near) zero is undefined.\")\n\n# ---------------------------------------------------------------------------\n# Arithmetic primitives\n# ---------------------------------------------------------------------------\n\ndef add(a: Number, b: Number) -> Number:\n    \"\"\"Return *a + b*.\"\"\"\n    _validate_numbers(a, b)\n    return a + b\n\n\ndef subtract(a: Number, b: Number) -> Number:\n    \"\"\"Return *a - b*.\"\"\"\n    _validate_numbers(a, b)\n    return a - b\n\n\ndef multiply(a: Number, b: Number) -> Number:\n    \"\"\"Return *a * b*.\"\"\"\n    _validate_numbers(a, b)\n    return a * b\n\n\ndef divide(a: Number, b: Number) -> Number:\n    \"\"\"Return *a / b*.\n\n    Raises\n    ------\n    ZeroDivisionError\n        If *b* is numerically zero (|b| < ``_NEAR_ZERO_TOLERANCE``).\n    \"\"\"\n    _validate_numbers(a, b)\n    _validate_non_zero_divisor(b)\n    return a / b\n\n\ndef power(a: Number, b: Number) -> Number:\n    \"\"\"Return *a* raised to *b*.\"\"\"\n    _validate_numbers(a, b)\n    return a ** b\n\n\ndef modulus(a: Number, b: Number) -> Number:\n    \"\"\"Return *a % b*.\n\n    Raises\n    ------\n    ZeroDivisionError\n        If *b* is numerically zero (|b| < ``_NEAR_ZERO_TOLERANCE``).\n    \"\"\"\n    _validate_numbers(a, b)\n    _validate_non_zero_divisor(b)\n    return a % b\n"
  },
  "time_taken": 27.60197615623474
}
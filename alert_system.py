#!/usr/bin/env python3
"""
Alert System

This module provides a centralized alert system for the FixWurx shell.
It allows the Auditor Agent to generate alerts and notifications when it
detects anomalies or issues in the system.
"""

import logging
import os
import sys
import json
import time
import uuid
from typing import Dict, List, Any, Optional, Union
from pathlib import Path

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("AlertSystem")

class AlertSystem:
    """
    Alert System for proactive notification of system issues.
    
    This class manages alerts generated by the Auditor Agent and other components.
    It handles alert creation, storage, notification, and management.
    """
    
    def __init__(self, config: Dict[str, Any] = None, registry: Any = None):
        """
        Initialize the Alert System.
        
        Args:
            config: Configuration dictionary
            registry: Component registry for accessing other components
        """
        self.config = config or {}
        self.registry = registry
        
        # Initialize alert storage directory
        self.alerts_dir = Path(self.config.get("alerts_dir", ".triangulum/alerts"))
        self.alerts_dir.mkdir(parents=True, exist_ok=True)
        
        # Alert severity levels
        self.severity_levels = ["info", "low", "medium", "high", "critical"]
        
        # Initialize alert counts
        self.alert_counts = {level: 0 for level in self.severity_levels}
        
        # Load existing alerts
        self.alerts = self._load_alerts()
        
        # Update alert counts
        for alert in self.alerts.values():
            severity = alert.get("severity", "info")
            if severity in self.alert_counts:
                self.alert_counts[severity] += 1
        
        logger.info("Alert System initialized")
    
    def _load_alerts(self) -> Dict[str, Dict[str, Any]]:
        """
        Load existing alerts from storage.
        
        Returns:
            Dictionary of alert objects indexed by alert ID
        """
        alerts = {}
        try:
            alert_files = list(self.alerts_dir.glob("*.json"))
            for alert_file in alert_files:
                try:
                    with open(alert_file, "r") as f:
                        alert = json.load(f)
                        if "id" in alert:
                            alerts[alert["id"]] = alert
                except Exception as e:
                    logger.error(f"Error loading alert file {alert_file}: {e}")
        except Exception as e:
            logger.error(f"Error loading alerts: {e}")
        
        logger.info(f"Loaded {len(alerts)} existing alerts")
        return alerts
    
    def create_alert(self, title: str, description: str, severity: str = "medium", 
                    source: str = "auditor", data: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Create a new alert.
        
        Args:
            title: Alert title
            description: Alert description
            severity: Alert severity level (info, low, medium, high, critical)
            source: Component that generated the alert
            data: Additional alert data
            
        Returns:
            The created alert object
        """
        # Validate severity
        if severity not in self.severity_levels:
            severity = "medium"
            logger.warning(f"Invalid severity level: {severity}, defaulting to 'medium'")
        
        # Generate alert ID
        alert_id = f"alert-{int(time.time())}-{uuid.uuid4().hex[:8]}"
        
        # Create alert object
        alert = {
            "id": alert_id,
            "title": title,
            "description": description,
            "severity": severity,
            "source": source,
            "timestamp": time.time(),
            "status": "new",
            "data": data or {},
            "actions_taken": []
        }
        
        # Store alert
        self._save_alert(alert)
        
        # Update internal state
        self.alerts[alert_id] = alert
        self.alert_counts[severity] += 1
        
        # Notify relevant components
        self._notify_alert(alert)
        
        logger.info(f"Created alert: {alert_id} - {title} ({severity})")
        return alert
    
    def _save_alert(self, alert: Dict[str, Any]) -> bool:
        """
        Save an alert to storage.
        
        Args:
            alert: Alert object to save
            
        Returns:
            True if saved successfully, False otherwise
        """
        try:
            alert_file = self.alerts_dir / f"{alert['id']}.json"
            with open(alert_file, "w") as f:
                json.dump(alert, f, indent=2)
            return True
        except Exception as e:
            logger.error(f"Error saving alert: {e}")
            return False
    
    def _notify_alert(self, alert: Dict[str, Any]) -> None:
        """
        Notify relevant components about a new alert.
        
        Args:
            alert: Alert object to notify about
        """
        # Try to create a bug if alert severity is high or critical
        if alert["severity"] in ["high", "critical"]:
            self._create_bug_from_alert(alert)
        
        # Emit event if event bus is available
        if self.registry:
            try:
                # Get component to emit events
                shell_env = self.registry.get_component("shell_environment")
                if shell_env and hasattr(shell_env, "emit_event"):
                    shell_env.emit_event("alert_created", {
                        "alert_id": alert["id"],
                        "severity": alert["severity"],
                        "title": alert["title"]
                    })
            except Exception as e:
                logger.error(f"Error emitting alert event: {e}")
    
    def _create_bug_from_alert(self, alert: Dict[str, Any]) -> None:
        """
        Create a bug report from an alert.
        
        Args:
            alert: Alert object to create a bug from
        """
        try:
            # Try to access command executor via shell access
            auditor_shell = None
            if self.registry:
                auditor_shell = self.registry.get_component("auditor_shell_access")
            
            if not auditor_shell:
                logger.warning("Auditor Shell Access not available, cannot create bug")
                return
            
            # Build bug create command
            bug_title = f"[{alert['severity'].upper()}] {alert['title']}"
            bug_description = f"{alert['description']}\n\nGenerated from alert: {alert['id']}"
            
            # Create bug using bug:create command
            command = f"bug:create --title \"{bug_title}\" --description \"{bug_description}\" --severity {alert['severity']}"
            
            # Execute command
            result = auditor_shell.execute_command(command)
            
            if result.get("success", False):
                # Update alert with bug ID
                bug_id = None
                output = result.get("output", "")
                
                # Try to extract bug ID from output
                import re
                match = re.search(r"Bug created: ([\w\d-]+)", output)
                if match:
                    bug_id = match.group(1)
                
                # Record action in alert
                action = {
                    "type": "bug_created",
                    "timestamp": time.time(),
                    "bug_id": bug_id,
                    "result": "success"
                }
                
                alert["actions_taken"].append(action)
                alert["status"] = "bug_created"
                self._save_alert(alert)
                logger.info(f"Created bug from alert: {alert['id']} -> {bug_id}")
            else:
                # Record failed action
                action = {
                    "type": "bug_created",
                    "timestamp": time.time(),
                    "result": "failed",
                    "error": result.get("error", "Unknown error")
                }
                
                alert["actions_taken"].append(action)
                self._save_alert(alert)
                logger.warning(f"Failed to create bug from alert: {alert['id']} - {result.get('error')}")
        except Exception as e:
            logger.error(f"Error creating bug from alert: {e}")
    
    def get_alert(self, alert_id: str) -> Optional[Dict[str, Any]]:
        """
        Get an alert by ID.
        
        Args:
            alert_id: Alert ID
            
        Returns:
            Alert object or None if not found
        """
        return self.alerts.get(alert_id)
    
    def update_alert(self, alert_id: str, update: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Update an existing alert.
        
        Args:
            alert_id: Alert ID
            update: Dictionary of fields to update
            
        Returns:
            Updated alert object or None if not found
        """
        alert = self.get_alert(alert_id)
        if not alert:
            return None
        
        # Update allowed fields
        allowed_fields = ["status", "description", "data"]
        for field in allowed_fields:
            if field in update:
                alert[field] = update[field]
        
        # Add action
        if "action" in update:
            action = update["action"]
            action["timestamp"] = time.time()
            alert["actions_taken"].append(action)
        
        # Save updated alert
        self._save_alert(alert)
        return alert
    
    def list_alerts(self, filters: Dict[str, Any] = None) -> List[Dict[str, Any]]:
        """
        List alerts with optional filtering.
        
        Args:
            filters: Dictionary of filters to apply
            
        Returns:
            List of matching alerts
        """
        filters = filters or {}
        result = []
        
        # Apply filters
        for alert in self.alerts.values():
            include = True
            
            # Filter by severity
            if "severity" in filters and alert["severity"] != filters["severity"]:
                include = False
            
            # Filter by status
            if "status" in filters and alert["status"] != filters["status"]:
                include = False
            
            # Filter by source
            if "source" in filters and alert["source"] != filters["source"]:
                include = False
            
            # Filter by time range
            if "start_time" in filters and alert["timestamp"] < filters["start_time"]:
                include = False
            if "end_time" in filters and alert["timestamp"] > filters["end_time"]:
                include = False
            
            if include:
                result.append(alert)
        
        # Sort by timestamp (newest first)
        result.sort(key=lambda x: x["timestamp"], reverse=True)
        
        # Apply limit
        if "limit" in filters and isinstance(filters["limit"], int):
            result = result[:filters["limit"]]
        
        return result
    
    def get_statistics(self) -> Dict[str, Any]:
        """
        Get alert statistics.
        
        Returns:
            Dictionary of alert statistics
        """
        # Count alerts by severity and status
        severity_stats = {level: 0 for level in self.severity_levels}
        status_stats = {"new": 0, "acknowledged": 0, "in_progress": 0, "resolved": 0, "bug_created": 0}
        
        for alert in self.alerts.values():
            severity = alert.get("severity", "info")
            status = alert.get("status", "new")
            
            if severity in severity_stats:
                severity_stats[severity] += 1
            
            if status in status_stats:
                status_stats[status] += 1
        
        # Get time-based statistics
        now = time.time()
        last_hour = now - 3600
        last_day = now - 86400
        
        alerts_last_hour = sum(1 for a in self.alerts.values() if a["timestamp"] >= last_hour)
        alerts_last_day = sum(1 for a in self.alerts.values() if a["timestamp"] >= last_day)
        
        return {
            "total_alerts": len(self.alerts),
            "by_severity": severity_stats,
            "by_status": status_stats,
            "alerts_last_hour": alerts_last_hour,
            "alerts_last_day": alerts_last_day,
            "latest_alert_time": max([a["timestamp"] for a in self.alerts.values()]) if self.alerts else None
        }

# Singleton instance
_instance = None

def get_instance(registry: Any = None, config: Dict[str, Any] = None) -> AlertSystem:
    """
    Get or create the singleton instance of the Alert System.
    
    Args:
        registry: Component registry
        config: Configuration dictionary
        
    Returns:
        AlertSystem instance
    """
    global _instance
    if _instance is None:
        _instance = AlertSystem(config, registry)
    return _instance

def register(registry: Any) -> None:
    """
    Register the Alert System with the component registry.
    
    Args:
        registry: Component registry
    """
    if registry:
        instance = get_instance(registry)
        registry.register_component("alert_system", instance)
        logger.info("Registered Alert System with component registry")

#!/usr/bin/env python3
"""
data_structures.py
────────────────
Core data structures for the FixWurx system.

This module provides common data structures used throughout the system,
including bug state, planner paths, and agent relationship tracking.
"""

import time
import json
import logging
from typing import Dict, List, Any, Optional, Set
from dataclasses import dataclass, field

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("data_structures")

@dataclass
class BugState:
    """
    Represents the state of a bug in the system.
    
    Attributes:
        id: Unique identifier for the bug
        phase: Current phase in the bug resolution process
        timer: Time elapsed since the bug was registered
        metadata: Additional metadata about the bug
    """
    id: str
    phase: Any = None  # Type is typically an enum from state_machine
    timer: float = 0.0
    start_time: float = field(default_factory=time.time)
    attempts: int = 0
    max_attempts: int = 3
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Initialize derived fields after initialization."""
        if self.metadata is None:
            self.metadata = {}
        # Initialize phase history
        if "phase_history" not in self.metadata:
            self.metadata["phase_history"] = []
            self.phase_history = self.metadata["phase_history"]


class PlannerPath:
    """
    Represents a solution path generated by the planner.
    
    A planner path is a sequence of actions that can be taken to resolve a bug.
    It includes an approach type, a success rate estimate, and a list of actions.
    """
    
    def __init__(self, path_id: str, bug_id: str, actions: List[Dict[str, Any]], 
                dependencies: Optional[List[str]] = None, fallbacks: Optional[List[Dict[str, Any]]] = None,
                metadata: Optional[Dict[str, Any]] = None):
        """
        Initialize a planner path.
        
        Args:
            path_id: Unique identifier for the path
            bug_id: ID of the bug this path addresses
            actions: List of actions in the path
            dependencies: Optional list of dependencies
            fallbacks: Optional list of fallback strategies
            metadata: Optional additional metadata
        """
        self.path_id = path_id
        self.bug_id = bug_id
        self.actions = actions
        self.dependencies = dependencies or []
        self.fallbacks = fallbacks or []
        self.metadata = metadata or {}
        self.created_at = time.time()
        self.last_updated = self.created_at
        self.execution_history = []
    
    def add_action(self, action: Dict[str, Any]) -> None:
        """Add an action to the path."""
        self.actions.append(action)
        self.last_updated = time.time()
    
    def add_dependency(self, dependency: str) -> None:
        """Add a dependency to the path."""
        if dependency not in self.dependencies:
            self.dependencies.append(dependency)
            self.last_updated = time.time()
    
    def add_fallback(self, fallback: Dict[str, Any]) -> None:
        """Add a fallback strategy to the path."""
        self.fallbacks.append(fallback)
        self.last_updated = time.time()
    
    def record_execution(self, action_index: int, result: Dict[str, Any]) -> None:
        """
        Record the execution of an action.
        
        Args:
            action_index: Index of the action in the actions list
            result: Result of the execution
        """
        execution_record = {
            "action_index": action_index,
            "result": result,
            "timestamp": time.time()
        }
        self.execution_history.append(execution_record)
        self.last_updated = time.time()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            "path_id": self.path_id,
            "bug_id": self.bug_id,
            "actions": self.actions,
            "dependencies": self.dependencies,
            "fallbacks": self.fallbacks,
            "metadata": self.metadata,
            "created_at": self.created_at,
            "last_updated": self.last_updated,
            "execution_history": self.execution_history
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PlannerPath":
        """Create from dictionary representation."""
        path = cls(
            path_id=data["path_id"],
            bug_id=data["bug_id"],
            actions=data["actions"],
            dependencies=data.get("dependencies", []),
            fallbacks=data.get("fallbacks", []),
            metadata=data.get("metadata", {})
        )
        path.created_at = data.get("created_at", time.time())
        path.last_updated = data.get("last_updated", path.created_at)
        path.execution_history = data.get("execution_history", [])
        return path


class FamilyTree:
    """
    Tracks relationships between agents in a hierarchical structure.
    
    The family tree represents agent relationships, with parent-child
    relationships defining the coordination hierarchy.
    """
    
    def __init__(self):
        """Initialize the family tree."""
        self.agents = {}
        self.relationships = {}
    
    def add_agent(self, agent_id: str, agent_type: str, metadata: Optional[Dict[str, Any]] = None) -> None:
        """
        Add an agent to the family tree.
        
        Args:
            agent_id: Unique identifier for the agent
            agent_type: Type of the agent (e.g., planner, observer)
            metadata: Optional metadata about the agent
        """
        self.agents[agent_id] = {
            "type": agent_type,
            "metadata": metadata or {},
            "added_at": time.time()
        }
        
        if agent_id not in self.relationships:
            self.relationships[agent_id] = {"parent": None, "children": []}
    
    def add_relationship(self, parent_id: str, child_id: str) -> bool:
        """
        Add a parent-child relationship to the family tree.
        
        Args:
            parent_id: ID of the parent agent
            child_id: ID of the child agent
            
        Returns:
            True if the relationship was added, False otherwise
        """
        # Check if agents exist
        if parent_id not in self.agents or child_id not in self.agents:
            return False
        
        # Ensure relationship entries exist
        if parent_id not in self.relationships:
            self.relationships[parent_id] = {"parent": None, "children": []}
        if child_id not in self.relationships:
            self.relationships[child_id] = {"parent": None, "children": []}
        
        # Remove child from previous parent if any
        if self.relationships[child_id]["parent"]:
            old_parent_id = self.relationships[child_id]["parent"]
            if old_parent_id in self.relationships:
                if child_id in self.relationships[old_parent_id]["children"]:
                    self.relationships[old_parent_id]["children"].remove(child_id)
        
        # Add child to new parent
        if child_id not in self.relationships[parent_id]["children"]:
            self.relationships[parent_id]["children"].append(child_id)
        
        # Set parent of child
        self.relationships[child_id]["parent"] = parent_id
        
        return True
    
    def get_parent(self, agent_id: str) -> Optional[str]:
        """
        Get the parent of an agent.
        
        Args:
            agent_id: ID of the agent
            
        Returns:
            ID of the parent agent, or None if the agent has no parent
        """
        if agent_id in self.relationships:
            return self.relationships[agent_id]["parent"]
        return None
    
    def get_children(self, agent_id: str) -> List[str]:
        """
        Get the children of an agent.
        
        Args:
            agent_id: ID of the agent
            
        Returns:
            List of IDs of the child agents
        """
        if agent_id in self.relationships:
            return self.relationships[agent_id]["children"]
        return []
    
    def save(self, file_path: str) -> bool:
        """
        Save the family tree to a file.
        
        Args:
            file_path: Path to save the file to
            
        Returns:
            True if the save was successful, False otherwise
        """
        try:
            data = {
                "agents": self.agents,
                "relationships": self.relationships,
                "saved_at": time.time()
            }
            
            with open(file_path, 'w') as f:
                json.dump(data, f, indent=2)
            
            return True
        except Exception as e:
            logger.error(f"Error saving family tree: {e}")
            return False
    
    @classmethod
    def load(cls, file_path: str) -> Optional["FamilyTree"]:
        """
        Load a family tree from a file.
        
        Args:
            file_path: Path to load the file from
            
        Returns:
            Loaded FamilyTree instance, or None if loading failed
        """
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
            
            tree = cls()
            tree.agents = data["agents"]
            tree.relationships = data["relationships"]
            
            return tree
        except Exception as e:
            logger.error(f"Error loading family tree: {e}")
            return None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            "agents": self.agents,
            "relationships": self.relationships
        }


@dataclass
class HistoryEntry:
    """
    Represents an entry in the MetaAgent's history.
    
    This class tracks the result of a bug fix attempt, including tokens used,
    success status, and path complexity if a path was used.
    
    Attributes:
        success: Whether the fix was successful
        tokens: Number of tokens used
        path_complexity: Complexity score of the path used (0.0 if no path)
        path_id: ID of the path used (None if no path)
        timestamp: When this entry was recorded
    """
    success: bool
    tokens: int
    path_complexity: float = 0.0
    path_id: Optional[str] = None
    timestamp: float = field(default_factory=time.time)
